函数传参：：
		基本类型：：函数参数新建基本类型（int， float， boolean等）
		引用类型：：就是参数指向传递的对象（String， Object）
空间复杂度：：看用掉的辅助空间O(1)
递归：：自然语言描述， 考虑特殊情况 + 普通递归情况
List::
	arrayList::
		用Arrays.copyOf(elements, newSize) 扩大长度
	linkedList::
		用Node和LinkList两个类， 初始化Head节点

Stack::
	本质用途就是回溯， 想到中断
	arrayStack::
		System.arraycopy(arr, 0, tmp, 0, total)实现stack， pop, push都要resize
		java.util.Arrays.toString(arr)用于toString输出
	linkedStack::
		 stack内部创建private class Node
		 始终在链表头部插入和删除 
		 pop要记得first = first.next
		 用StringBuilder()去toString整个stack
Queue::
	arrayQueue::
		注意利用头指针移动过的地方，用next， first两个指针实现
		resize()注意取arr.length的余数
		用java.util.Arrays.toString(arr)实现toString
	linkedQueue::
		用first， last两个指针实现
		enqueue（）注意初始first = last， dequeue（）注意设置last = null
		toString()用StringBuilder()
	deque：：
		双端队列
		用ArrayList实现
	arrayDeque：：
		数组实现Deque
		只能在初始化的时候指定capacity
		默认长度是16
	priorityQueue：：
		用最小堆、最大堆实现， 这就是为什么堆插入，从最后一个元素开始"上浮"
		删除root， 用队尾元素放到root， "下沉""

HashMap::
	hashFunction产生hashcode， 除以数组长度， 得到余数， 就是value的位置
	用key查找， 也是通过hashFunction
	0.75的resize（） factor
	用到<<, >>操作
HashSet::
	用HashMap， 把元素作为key， 核心是map.put(e, PRESENT)
	0.75的resize（）
	用到<<, >>操作
Binary tree：：
	用好递归， 遍历， 插入需要用到
	一个Node有Node left; Node right;	
	完全二叉树的某个结点到根结点的距离为log2i+1
Binary heap::
	是完全二叉树， 一般通过"数组"实现
	分两种：：最大堆和最小堆
	在最后节点后添加，然后上升； 删除根节点， 把最后节点放根， 然后下沉； 删除任意节点， 要对比父亲节点和子节点
	leftNo = parentNo*2+1
	rightNo = parentNo*2+2
	parentNo = (nodeNo-1)/2
	构建堆的复杂度：：S = n - ㏒n +1 = O(n)， 方法是：：从一个节点开始不断插入

Graph：：
	概念：：
		G = (V, E), Vertex顶点， Edge边
		点对（v，w）是有序， 叫有向图； 无序， 叫无向图
		顶点v和w邻接（adjacent）当且仅当（v，w）属于E
		边的属性：：例如：：权值（cost）
		边上带权值的图称为网络（network）
		入度（indegree）是指的顶点v的边（u，v）的条数
	图分类：：
		完全图：：
			complete graph是其每一对不同顶点间恰有一条边的图， 可以有向， 可以无向
		稀疏图：：
			sparse graphs， 边很少的图
		连通图：：
			定义：：无向图中从每一个顶点到其他每个顶点都存在一条路径， 称该无向图是连通的（connected）
			判断无向图是否连通：：
				步骤：：
					每个节点：：
						调用bfs()或dfs() 
						是否存在未被访问过的顶点
			连通度：：
				若在连通图上至少删去k个顶点才能破坏图的连通性，则称此图的连通度为k	
		无向图：：
			如果图不是连通的，那么处理所有的结点（以及边）自然需要多次反复调用dfs，每次都生成一棵树，整个集合就是深度优先生成森林（depth-first spanning forest）
		强连通：：
			每一个顶点到其他每个顶点都存在一条路径的有向图称为是强连通的的（strongly connected）
			强连通分量：：
				有向图的极大强连通子图，称为强连通分量(strongly connected components)	
		弱连通：：
			如果有向图不是强连通的，但它的基础图（underlying graph）（去掉方向所形成的图）是连通的，那么称该有向图是弱连通的（weakly connected）
		双连通图：：
			定义：：
				如果删除一个无向图的任一顶点后，剩下的图仍然连通，那么这样的无向连通图就称为是双连通的（biconnected）
				也可理解为：：一个没有关节点的连通图称为重连通图(biconnected graph)
			两种：：点双连通分量， 边双连通分量
			点（边）双连通图：： 
				若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥）
			无向图的点（边）双连通分量：： 
				一个无向图中的每一个极大点（边）双连通子图
			求双连通分量：：
				可用Tarjan算法
			割点：：
				articulation point， 如果图不是双联通的，那么将其删除后不再连通的那些顶点叫做割点	
				求割点：：
					本质就是求：：在图中寻找强连通分量
					两类节点是割点：：
						1， 对根节点u，若其有两棵或两棵以上的子树，则该根结点u为割点
						2， 对非叶子节点u（非根节点），若其子树的节点均没有指向u的祖先节点的回边（回到祖先），说明删除u之后，根结点与u的子树的节点不再连通；则节点u为割点
					Tarjan算法：：
						算法：：DFS + 栈次序号（dfn[u]）的最小值（low[u]）
						时间复杂度：：O(V+E)
	API::
		创建图Graph Create()
		插入顶点：：Graph InsertVertex (graph, v)
		插入边：：Graph InsertEdge (graph, v1，v2)
		删除顶点：：Graph DeleteVertex (graph, v)
		删除边：：Graph DeleteEdge (graph，v1，v2)
		空图：：Boolean IsEmpty (graph)
		顶点v的所有邻接结点：：List Adjacent (graph, v)
	存储方式：：
		邻接矩阵：：
			 定义：：
			 	adjacency matrices，|V|∗|V|的二维数组来表示图， g[i][j]表示顶点i和顶点j的关系
			 	有向图不需要满足g[i][j]=g[j][i]
			 	带权图中，g[i][j]表示顶点i到顶点j的边的权值
				边不存在， 用g[i][j]=INF
			 	一条边上有多种不带权值的情况，可定义多个同样的|V|∗|V|数组，或使用结构体或类作为数组的元素
			 复杂度：：
			 	任意一个顶点i的度等于其邻接矩阵中顶点i所对应的行中的数字之和
			 	扫描所有边至少需要O(n^2), 
			 	n^2−n次，邻接矩阵对角线上的n个元素都是0，因此不用检查
			 	无向图的邻接矩阵是对称的，实际只需检查邻接矩阵的一半元素
			 缺点：：浪费大量内存
		邻接表（adjacency lists）
			每一行是（顶点 ＋ 相邻的顶点）， 只需O(|V|+|E|)内存
			有向图， 相邻的意思， 就是出度
			缺点：：
				删除边，需要删除两个节点
				得到出度，但入度就必须要遍历整个图，反之，逆邻接表解决了入度，却没解决出度
		邻接多重表（adjacency multilists）
			本质：：
				顶点表 ＋ 边表
				顶点连边， 边边相连
			构成：：
				节点连接边； 边通过左右节点，找到相邻边， 连接起来；入度做出度， 出度做入度
			十字链表：：
				Orthogonal List， 邻接表与逆邻接表结合起来
				横向连出度， 纵向连入度
			解决无向图中， (vi, vj), (vj, vi)的重复问题
	搜索：：
		广度优先：：
			breadth-first search， 距起始点最近的那些顶点首先被访问， 很像树的层序遍历（level-order traversal）
			邻接矩阵/邻接表实现：：
				保存访问过的节点（list或map） + 扫描行保存相连节点（queue）
			步骤：：
				1， 节点入队列
				2， 该节点出队列， 并扫描该节点的行， 如果邻接存在， 且没被访问， 将邻接节点入队列
				3， 单个节点， 终止条件是， 该节点没有还没访问的节点， 且队列清空
			时间复杂度：：O(n^2)
		深度优先：：
			Depth First Search， 和树的先序遍历类似， 递归过程
			保存访问过的节点（list或map） + 向下扫描，保存相连节点（stack）
			步骤：：
				1， 节点入栈
				2， 访问该节点， 并扫描该节点下一个邻接节点， 如果邻接存在， 且没被访问， 入栈
				3， 直到节点没有邻接节点， 出栈， 判断栈顶元素的邻接节点是否入栈
				4, 单条递归线路， 终止条件是， 该节点没有向下和向右（邻接节点）的没访问的节点， 
			时间复杂度：：邻接矩阵O(n^2), 邻接表O(e)
	偏序、全序：：
		全序：：两个元素的顺序确定
		偏序：：两个元素顺序不确定， 但不能有环
		理解：：
			不同整数之间的大小关系--全序
			相同值的元素--偏序
			插入排序， 加入出现顺序的潜在比较， 因此将偏序转为了全序
			a > b, b > c => a > c --这就是全序关系中传递性
	传递闭包：：
		定义：：如果(<a, b>, <b, c>)在集合里， 则<a, c>也在集合里
		算法：：Warshell算法， 是三重循环
	拓扑排序：：
		非有向无环图是不能被拓扑排序的
		是对有向无环图的顶点的一种排序
		如果存在一条从vi到vj的路径，那么在排序中vj出现在vi的后面
		步骤：：
			1， 选中一个没有入边的顶点，显示出该点，并将它和它的边一起从图中删除
			2， 然后对图的其余部分应用同样的方法处理
		拓扑排序中，结果具有唯一性的条件是其所有顶点之间都具有全序关系， 如果没有这一层全序关系，那么拓扑排序的结果也就不是唯一的
		如果拓扑排序的结果唯一，那么该拓扑排序的结果同时也代表了一条哈密顿路径
		实现算法：：
			Kahn算法：：
				本质：：从没有入度开始
				步骤：：
					关键在于需要维护一个入度为0的顶点的集合
					循环遍历由该顶点引出的所有边，从图中移除这条边，同时获取该边的另外一个顶点，如果该顶点的入度在减去本条边之后为0，那么也将这个顶点放到入度为0的集合中
					当集合为空之后，检查图中是否还存在任何边，如果存在的话，说明图中至少存在一条环路。不存在的话则返回结果List，此List中的顺序就是对图进行拓扑排序的结果
				复杂度：：O(V+E)
			基于DFS的算法：：
				本质：：没有出度， 递归结束
				步骤：：
					如果用递归：：直接在访问完字节点后， 将当前节点加入栈中
					如果用非递归（栈实现）：：直接将栈出栈， 然后反向； 或是加入一个新栈
				复杂度：：O(V+E)
	判断图是否有环：：
		两种算法：：
			Kahn算法：：那么在出度为0的集合为空之后，图中还存在没有被移除的边，这就说明了图中存在环路
			DFS::
				递归法：： 在调用dfs方法时，将当前顶点记录到调用栈中； 当w已经被访问，同时w也存在于调用栈中时，即存在环路
				非递归：： 新节点插入栈时， 直接检查元素是否存在
	哈密顿路径：：
		一条从给定的起点到给定的终点， 沿途恰好经过所有节点一次的路径
		哈密顿回路：：
			指一条能够对图中所有顶点正好访问一次的路径
		DAG表示无环图
		非DAG也是能够含有哈密顿路径
		无环图的算法：：
			1， 拓扑排序
			2， 依次检查排序结果中每一对相邻顶点， 如果每对相邻顶点都存在着一致的先后关系， 则存在哈密顿路径， 反之则不存在
		有环图：：略
	欧拉回路：：
		从任意点出发，经过所有边恰好一次， 并最终回到出发顶点 
		无向图存在欧拉回路的充要条件：：
			当且仅当该图所有顶点度数都为偶数,且该图是连通图数
	小结：：
		1， 搜索用BFS， DFS都可以，适用于所有图， 不管有不有环
		2， DFS + 栈判断， 可以找环
		3， 有向无环图才能拓扑排序
		4， 有向无环图的哈密顿路径是，先拓扑排序， 在逐个判断每个相邻元素有相同顺序
		5， 对每个不重复访问的节点都调用dfs， 可以组成森林 
		6， 看到图， 就要想到存储方式
		7， 判断是否已经访问过， 很重要
	单源最短路径：：
		定义：：计算一个节点到其他所有节点的最短路径
		判断负环：：
			因为负权环可以无限制的降低总花费，所以如果发现第n次操作仍可降低花销，就一定存在负权环
		Dijkstra算法：：
			范围：：加权图（有向，无向都可以）， 且权不为负值， 可以有环 
			思想：：贪心（greedy）
			算法：：
				1， 更新当前节点的下一个节点的路径
				2， 跳到未访问且路径最短的节点
			时间复杂度：：斐波纳契堆：：O(|E| + |V|log|V|)， 二叉堆 O((|E| + |V|)log|V|)
				斐波那契堆：：
					多棵最小堆按跟节点拍成直线
					节点间用循环双向链表向连
					不涉及删除元素的操作有O(1)的平摊时间
		Bellman–Ford::
			可以用负权， 时间复杂度O(|V||E|)
		Floyd-Warshall算法：：
			范围：：正确处理无向图，有向图或负权， 但不可存在负权回路
			思想：：动态规划
			时间：：O(N^3)， 空间：：O(N^2)
	最小生成树：：
		生成树：：
			定义：：
				所有顶点均由边连接在一起（G是连通图），但不存在回路的图
			特征：：
				顶点个数与图的顶点个数相同
				是图的极小连通子图
		最小生成树：：
			定义：：生成树的每条边上的权值之和最小
			实例：：在N个城市之间修路，总路线的总和最小问题
		加权连通图里搜索最小生成树
		Prim算法：：
			思想：：树不断成长
			算法：：
				将图看成n个孤立点
				选取最小权值的边， 将连接的节点看作整体
				再选取连接这个整体最小的边， 直到选取所有的顶点
			时间复杂度：：O(|E| + |V|log|V|)
		Kruskal算法：：
			思想::贪心
			算法：：
				将图看成n个孤立点
				每次选取最小的边， 但保证， 边的两个节点不能都在已经已经选取的节点中
				直到选取所有的顶点
			时间复杂度：：ElogE
	AOE：：
		定义：：
			Activity on Edge, 在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间
		本质：：
			节点多了时间属性， 和关键路径联系在一起
	AOV::
		定义：：
			Activity on Vertices
		本质：：
			节点没有时间， 通常只是拓扑排序， 节点加上时间， 就可转为AOE网， AOV网不能有有向环
	关键路径：：
		每个节点包括（<最早开始，最早结束>duration<最晚开始， 最晚结束>）的AOE网
		图必须是无环的
		从源点(source)到汇点(sink)具有最大长度的路径， 一个工程不一定有一条关键路径，可能会有多条
		算法：：
			1， 拓扑排序，并求得所有节点的<最早开始，最早结束>
				如果得到的拓扑有序序列中顶点个数小于网中顶点数n，则说明网中存在环，不能求关键路径
			2， 拓扑逆序，并求得所有节点的<最晚开始， 最晚结束>
			3， 若节点<最早开始，最早结束> == <最晚开始， 最晚结束>则为关键活动（critical activity）， 组成的路径就是关键路径
	网路流：：
		通俗理解：：自来水厂 + 家
		三个性质：：
			1， 容量限制：：容量 >= 流量
			2， 流量守恒：：流入量 === 流出的量
			3， 斜对称性：：x到y是正流量， 则y到x是负流量
		网络：：就是有源、汇的有向图
		容量网络：：就是关于容量的网络， 基本是不改变的
		流量网络：：就是关于流量的网络， 在求解问题的过程中， 通常在不断的改变， 但是总是满足上述三个性质
			   调整到最后就是最大流网络 同时也可以得到最大流值
		残留网络：：
			   残留流量=容量-流量
			   只利用流量<容量的边或流量大于零的负边组成的图
			   当流量值为负时， 残留值甚至会大于容量值
		增广路算法：：
			增广路定义：：
				从s到t的路径， 路径上每条边残留容量都为正
				或定义为：：残余网络上， s到t的路径
			基础：：
				增广路定理：：
					Augmenting Path Theorem， 网络达到最大流当且仅当残留网络中没有增广路
		割（边）：：
			通俗理解：：完全割成两部分， 不能连接
			无向图的割集::(Cut Set), C[A,B]是将图G分为A和B两个点集, A和B之间的边的全集
			网络的割集::C[S,T]是将网络G分为s和t两部分点集 S属于s（源）且T属于t（汇）， 从S到T的边的全集
			带权图的割::(Cut)就是割集中边或者有向边的权和
		网络最大流::
			以送货为例， 在可行的情况下，从一个节点到另一个节点所能送达的最大货量即为最大流
			Edmonds-Karp算法::
				别称：：最短路径增广算法 简称EK算法
				基于增广路算法
				思路：：不断的找最短路， 找的方法就是每次找一条边数最少的增广， 也就是最短路径增广
				复杂度：：
					最多O(VE)次增广 可以达到最大流广
		最小割：：
			割边权值和最小
			假设切割水管付出的代价和水管容量成正比	
		最大流、最小割：：
			Ford–Fulkerson算法：：
				思想：：深度搜索
				步骤：：
					1， 只利用流量<容量的边或流量大于零的负边， 寻找s到t的路径
					2， 其中， 反向流在正向流的基础上相减， 容量不变， 正向、反向共用一个<f, c>对
					3， 流量满的路径也能再使用， 如果不存在路径， 则结束； 否则沿着该路径， 尽可能地增加流
				时间复杂度：：F表示最大流量， O（F|E|）
			Dinic算法：：
				思想：：宽度搜索 ＋ 深度搜索
				步骤：：
					1， 在图中标记层次
					2， 每次找s-t的增广路径的瓶颈边和对应的节点，更新增广路径
					3， 继续在包含瓶颈节点的增广路上，找瓶颈边和节点， 直到没有增广路径
				时间复杂度：：O（|E||V|^2）
		最大流最小割定理：： 
			核心：：网络的最大流等于最小割
			应用：：
				1， 对于多源多汇问题，只需要添加一个超源点和一个超汇点，将其转化为单源单汇问题
				2， 对于在顶点处有流量限制的问题， 新的图的顶点数是源图的两倍
		最小费用流：：
			问题：：保证流量为F的前提下， 使得费用最小
		线性规划问题：：
			单纯形法：：
				simplex algorithm
			Karmarkar算法：：略
Sort：：
	排序算法是否稳定，即值相同的元素的排序结果是否和出现的顺序一致
	堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法
	冒泡：：
		数字往后冒， n~1, n方
	插入：：
		新建array， 无序数插有序数， 1~n, n方
		稳定排序
	选择：：
		每次选最大/小, 不用堆， n~1, n方
	希尔：：
		分组插入排序：：子序列分别进行直接插入排序，子序列增量缩减，直到1， 
		O(n^3/2)， 好于直接插入排序的O(n^2)
		不创建新数组， 直接通过Gap后的每个元素， 做直接插入排序
	归并：：
		从两个元素的小组， 不断merge， 快排思维， 和希尔的逆思想类似， 但每次排序都是merge， 不是直接插入
		每次分两部分， 两个操作， sort（）， merge（）
		时间最好， 最坏都是O(nlogn)， 空间O(n)
	堆排序：：
		不断取堆顶
		O(nlgn)， 最坏：O(nlgn)， 空间复杂度：O(1)
	快排：：
		二分思想， 每次随意选最分隔元素， 递归调用
		O（n*lgn）， 最坏：O（n^2）， 空间复杂度：最好，O（logn）， 最坏O（n）
		不稳定排序
	计数：：
		Counting sort， 稳定的排序算法
		适用于正整数， 基本思想是：：数组元素值对应数组索引
		使用一个额外的数组C， 找出最大、最小值， 长度 = Max - Min
		对于数据范围很大的数组，需要大量时间和内存
	桶排序：：
		Bucket sort， 稳定排序， 比快排快， 非常耗空间
		元素属于固定(有限的)的区间, 数据的分布必须均匀
		选出最大，最小值， 划分区间， 桶内排序可用插入排序等
		每个桶就是一个ArrayList， 桶为1时， 和计数排序类似， 区别在于存储元素实际值， 不是存个数
		最差，O(n2)； 最好O(n+k), 空间O(n+k)auxiliary 
	基数排序：：
		Radix sort， 按位从低到高排序， 原因是从影响较小的开始更好
		正、负整数、浮点数都适用
		每次调用桶排序； 如果只是十进制正整数， 则用余数； 其他如浮点数， 则用位运算， 取特定位， 用移位和&得到
		对于负数， 注意最后一步， 整数部分要和负数部分调换
		n个d位数， O(dn+kd)
查找：：
	总体方法：：
		二分， 树， 索引， Hash
	二分：：
		二分查找：：low + 1/2(high - low)
		插值查找：：
			mid根据key离low的距离来定， 不一定是二分，目的是让mid值的变化更靠近关键字key
			mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); 
			如果关键字分布比较均匀， 平均性能比折半查找要好的多
		斐波那契查找::
			利用斐波那契数列的性质，黄金分割的原理来确定mid的位置
			数列越往后, 相邻的两个数的比值越趋向于黄金比例值（0.618）
			n=F(k)-1，n是要排序数组的长度； mid=low+F(k-1)-1， mid左边元素比右边多
			每次判断后， 注意k的变化； 找到相等的值时， 要判断是否为扩展值
			O(logn)，平均性能， 优于折半查找； 最坏情况比折半差
		小结：：
			折半进行加法与除法运算（mid=(low＋high)/2）
			插值查找进行复杂的四则运算（mid=low＋(high-low)*(key-a[low])/(a[high]-a[low])）
			斐波那契查找只是最简单加减法运算（mid=low＋F[k-1]-1）， 在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率
	索引：：
		本质：：两部分， 关键字：记录
		线性索引：：
			稠密索引：：
				按照关键字有序的排列， 每个记录对应一个索引项， 索引项与数据集的记录个数相同
				可以用到折半、插值、斐波那契等查找
			倒排索引：：
				Inverted index， 常用于"查询那些文件包含了某单词"
				本质：：file：content中， 把content里的关键字作为key， 把file作为value
				缺点：：记录号不定长，维护比较困难，插入和删除操作都需要作相应的处理
			分块索引：：
				两条件：：
					块内无序
					块间有序
					例如：：要求第二块所有记录的关键字均要大于第一块中所有记录的关键字
				三内容：：
					每一块中的最大关键字
					块中的记录个数
					指向块首数据元素的指针
				两步：：
					找块：：二分等查找
					找元素：：顺序查找
				最佳情况：：
						分的块数m与块中的记录数t相同
						查找的平均长度=1/2·(n/t+t)+1=t+1=sqrt(n)+1
	二分树和多路树：：	
		多路查找树（muitl-way search tree）：：
			本质也是索引
			2-3树：：
				就是Max degree为3的B树（阶为3）， 也就是节点中元素个数最多为2， 儿子对多为3
				时间复杂度O(logn)
			2-3-4树：：
				就是Max degree为4的B树（阶为4）， 也就是节点中元素个数最多为3， 儿子对多为4
				时间复杂度O(logn)
			B树：：
				设定每个节点最大元素个数 + 1 = 每个节点最多能有的孩子数（degree）
				用于硬盘数据量很大时， 将节点度数调大， 然后可以只读入根节点， 快速查找元素所在块
				搜索， 插入， 删除O(logn)； 空间O(n)
			B+树：：
				所有节点放在叶子节点上，比B树多了非叶子节点的复制，和叶子节点之间的指针
				遍历更方便
				所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字
				删除时，记得删节点对应的索引
			B*树：：
				是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针
		树状数组：：
			Binary Indexed Tree：：
				定义：：
					1， 建立树关系：：
						整体：：儿子推出父亲
						Ci表示indexed的第i项和
						Ai表示原数组第i项的值， i从1开始
						Sum（i）， 表示Ai的前i项和
				理解Ci：：
					找父亲， 就是儿子下标， 从右往左第一个"1"的位置， 加上1 == 父亲下标
					找最左儿子， 就是父亲下标， 从右往左第一个"1"的位置， 减去1， 再在结果值加上1
					Ci就是， 父亲下标开始， 往前数２^k项的和， 包括父下标的值
					公式：：Ci  =  sum{ A[j] |  i – 2^k+ 1 <= j <= i }
						Ci = sum {A[i-lowbit(i)+1]  ~ A[i]}
				理解Sum（i）：：
					A[i]的前i项和
					sum(i) = sum( i – lowbit(i) ) + C[i]
					递归：：
						int sum(int x){
						     return x ? C[x]+ sum( x - lowbit(x)):0;
						}
					非递归：：
						int sum(int x){
					        int s =0;
					        for(int i = x; i ; i -= lowbit(i)){
					            s += c[i];
					        }
					        return s;    
					    }
				理解add(i, v)：：
					在A[i]， 加上v， 只影响自己和祖先结点
					v可以是负数
					如果需要求[x, y]的和，只需要求两次sum函数，然后相减得到，即sum(y) – sum(x-1)
					递归：：
						void add(int x,int v){
						     if(x <= n){
						         C[x]+= v, add( x + lowbit(i), v );
						     }
						}
					非递归：：
						void add(int x,int v){
						    for(int i = x; i <= n; i += lowbit(i)){
						        C[i] += v;
						    }
						}
				理解lowbit（i）：：
					2^i末尾零的数量
					用补码， 与运算， O（1）实现：：
						int lowbit(int x) {
						     return x & -x;
						}
				用途：：点更新，段求和； 段更新，点求值； 逆序模型， 将元素本身作为树状数组的下标
				记忆：：
					lowbit(i)用来找父亲或儿子
					Ci， Sum(i)找儿子， add(i, v)找父亲
					时间复杂度为O(log(n))，空间复杂度为O(n)

		二叉搜索树：：
			左孩子比父节点小，右孩子比父节点大
			中序遍历，可以让结点有序
		平衡二叉树：：
			AVL， 也叫Self-Balancing Binary SearchTree或Height-Balanced Binary Search Tree
			旋转看作拉动齿轮：：
				基础：：它首先是一个二叉排序树
				本质：：二叉排序树， 左小右大
				四种情况：：
					旋转都是三个步骤：：长边做根， 切断长边，原根做另一边 
					最后更新高度：：
						node.height = Math.Max(Height(node.left), Height(node.right)) + 1;
	             		top.height = Math.Max(Height(top.left), Height(top.right)) + 1;
					左左：：
						var top = node.left;
						node.left = top.right;
						top.right = node;
					右右：：
						var top = node.right;
						node.right = top.left;
						top.left = node;
					左右：：
						两次旋转：：
							失衡点的左节点执行右右
							失衡点执行左左
							node.left = RotateRR(node.left);
							return RotateLL(node);
					右左：：
						两次旋转：：
							失衡点的右节点执行左左
							失衡点执行右右
							node.right = RotateLL(node.right);
							return RotateRR(node);
				插入：：
					Height(tree.right) - Height(tree.left) == 2时旋转
					出现了哪一种情况调用哪一种方法
					重复元素加到根节点的set里
				删除：：
					删除中间节点：：
						先删除， 然后用左右高度判断， 使用哪种旋转
					删除根：：
						有两个孩子的情况：：
							找到”右子树“的最小节点：：
								tree.key = FindMin(tree.right).key;
							删除右子树的指定元素：：
								tree.right = Remove(tree.key, value, tree.right);
						只有一边有：：
							tree = tree.left == null ? tree.right : tree.left;
						叶子节点：：
							if (tree == null) {return null};
		Treap：：就是二叉排序树 + 优先级的堆， 一个节点含有value和优先级

	哈希表查找：：
		哈希（Hash）函数 +　记录存储在一块连续的存储空间
		解决冲突：：
			两种方法：：
				跳空格
				重复元素存链表
