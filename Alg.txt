函数传参：：
		基本类型：：函数参数新建基本类型（int， float， boolean等）
		引用类型：：就是参数指向传递的对象（String， Object）
空间复杂度：：看用掉的辅助空间O(1)
递归：：自然语言描述， 考虑特殊情况 + 普通递归情况
List::
	arrayList::
		用Arrays.copyOf(elements, newSize) 扩大长度
	linkedList::
		用Node和LinkList两个类， 初始化Head节点

Stack::
	本质用途就是回溯， 想到中断
	arrayStack::
		System.arraycopy(arr, 0, tmp, 0, total)实现stack， pop, push都要resize
		java.util.Arrays.toString(arr)用于toString输出
	linkedStack::
		 stack内部创建private class Node
		 始终在链表头部插入和删除 
		 pop要记得first = first.next
		 用StringBuilder()去toString整个stack
Queue::
	arrayQueue::
		注意利用头指针移动过的地方，用next， first两个指针实现
		resize()注意取arr.length的余数
		用java.util.Arrays.toString(arr)实现toString
	linkedQueue::
		用first， last两个指针实现
		enqueue（）注意初始first = last， dequeue（）注意设置last = null
		toString()用StringBuilder()
	deque：：
		双端队列
		用ArrayList实现
	arrayDeque：：
		数组实现Deque
		只能在初始化的时候指定capacity
		默认长度是16
	priorityQueue：：
		用最小堆、最大堆实现， 这就是为什么堆插入，从最后一个元素开始"上浮"
		删除root， 用队尾元素放到root， "下沉""

HashMap::
	hashFunction产生hashcode， 除以数组长度， 得到余数， 就是value的位置
	用key查找， 也是通过hashFunction
	0.75的resize（） factor
	用到<<, >>操作
HashSet::
	用HashMap， 把元素作为key， 核心是map.put(e, PRESENT)
	0.75的resize（）
	用到<<, >>操作
Binary tree：：
	用好递归， 遍历， 插入需要用到
	一个Node有Node left; Node right;	
	完全二叉树的某个结点到根结点的距离为log2i+1
Binary heap::
	是完全二叉树， 一般通过"数组"实现
	分两种：：最大堆和最小堆
	在最后节点后添加，然后上升； 删除根节点， 把最后节点放根， 然后下沉； 删除任意节点， 要对比父亲节点和子节点
	leftNo = parentNo*2+1
	rightNo = parentNo*2+2
	parentNo = (nodeNo-1)/2
	构建堆的复杂度：：S = n - ㏒n +1 = O(n)， 方法是：：从一个节点开始不断插入

Graph：：
	小结：：
		搜索用BFS， DFS都可以，适用于所有图， 不管有不有环
		DFS + 栈判断， 可以找环
		有向无环图才能拓扑排序
		有向无环图的哈密顿路径是，先拓扑排序， 在逐个判断每个相邻元素有相同顺序
		对每个不重复访问的节点都调用dfs， 可以组成森林 
	看到图， 就要想到存储方式
	判断是否已经访问过， 很重要
	搜索：：
		广度优先：：
			breadth-first search， 距起始点最近的那些顶点首先被访问， 很像树的层序遍历（level-order traversal）
			邻接矩阵/邻接表实现：：
				保存访问过的节点（list或map） + 扫描行保存相连节点（queue）
			步骤：：
				1， 节点入队列
				2， 该节点出队列， 并扫描该节点的行， 如果邻接存在， 且没被访问， 将邻接节点入队列
				3， 单个节点， 终止条件是， 该节点没有还没访问的节点， 且队列清空
			时间复杂度：：O(n^2)
		深度优先：：
			Depth First Search， 和树的先序遍历类似， 递归过程
			保存访问过的节点（list或map） + 向下扫描，保存相连节点（stack）
			步骤：：
				1， 节点入栈
				2， 访问该节点， 并扫描该节点下一个邻接节点， 如果邻接存在， 且没被访问， 入栈
				3， 直到节点没有邻接节点， 出栈， 判断栈顶元素的邻接节点是否入栈
				4, 单条递归线路， 终止条件是， 该节点没有向下和向右（邻接节点）的没访问的节点， 
			时间复杂度：：邻接矩阵O(n^2), 邻接表O(e)
	连通图：：
		判断无向图是否连通：：
			步骤：：
				每个节点：：
					调用bfs()或dfs() 
					是否存在未被访问过的顶点
	双连通图：：
		也叫双连通分量
		两种：：点双连通分量， 边双连通分量
		若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图
		一个无向图中的每一个极大点（边）双连通子图称作此无向图的点（边）双连通分量
		求双连通分量可用Tarjan算法
		强连通分量：：
			有向图的极大强连通子图，称为强连通分量(strongly connected components)
	偏序、全序：：
		全序：：两个元素的顺序确定
		偏序：：两个元素顺序不确定， 但不能有环
		理解：：
			不同整数之间的大小关系--全序
			相同值的元素--偏序
			插入排序， 加入出现顺序的潜在比较， 因此将偏序转为了全序
			a > b, b > c => a > c --这就是全序关系中传递性
	拓扑排序：：
		非有向无环图是不能被拓扑排序的
		是对有向无环图的顶点的一种排序
		如果存在一条从vi到vj的路径，那么在排序中vj出现在vi的后面
		步骤：：
			1， 选中一个没有入边的顶点，显示出该点，并将它和它的边一起从图中删除
			2， 然后对图的其余部分应用同样的方法处理
		拓扑排序中，结果具有唯一性的条件是其所有顶点之间都具有全序关系， 如果没有这一层全序关系，那么拓扑排序的结果也就不是唯一的
		如果拓扑排序的结果唯一，那么该拓扑排序的结果同时也代表了一条哈密顿路径
		实现算法：：
			Kahn算法：：
				本质：：从没有入度开始
				步骤：：
					关键在于需要维护一个入度为0的顶点的集合
					循环遍历由该顶点引出的所有边，从图中移除这条边，同时获取该边的另外一个顶点，如果该顶点的入度在减去本条边之后为0，那么也将这个顶点放到入度为0的集合中
					当集合为空之后，检查图中是否还存在任何边，如果存在的话，说明图中至少存在一条环路。不存在的话则返回结果List，此List中的顺序就是对图进行拓扑排序的结果
				复杂度：：O(V+E)
			基于DFS的算法：：
				本质：：没有出度， 递归结束
				步骤：：
					如果用递归：：直接在访问完字节点后， 将当前节点加入栈中
					如果用非递归（栈实现）：：直接将栈出栈， 然后反向； 或是加入一个新栈
				复杂度：：O(V+E)
	判断图是否有环：：
		两种算法：：
			Kahn算法：：那么在出度为0的集合为空之后，图中还存在没有被移除的边，这就说明了图中存在环路
			DFS::
				递归法：： 在调用dfs方法时，将当前顶点记录到调用栈中； 当w已经被访问，同时w也存在于调用栈中时，即存在环路
				非递归：： 新节点插入栈时， 直接检查元素是否存在
	哈密顿路径：：
		一条从给定的起点到给定的终点， 沿途恰好经过所有节点一次的路径
		哈密顿回路：：
			指一条能够对图中所有顶点正好访问一次的路径
		DAG表示无环图
		非DAG也是能够含有哈密顿路径
		无环图的算法：：
			1， 拓扑排序
			2， 依次检查排序结果中每一对相邻顶点， 如果每对相邻顶点都存在着一致的先后关系， 则存在哈密顿路径， 反之则不存在
		有环图

	欧拉回路：：
		从任意点出发，经过所有边恰好一次， 并最终回到出发顶点


	最小生成树：：
		生成树：：
			定义：：
				所有顶点均由边连接在一起，但不存在回路的图
			特征：：
				顶点个数与图的顶点个数相同
				是图的极小连通子图
		最小生成树：：
			定义：：生成树的每条边上的权值之和最小
			实例：：在N个城市之间修路，总路线的总和最小问题
		加权连通图里搜索最小生成树
		Prim算法：：
			思想：：树不断成长
			算法：：
				将图看成n个孤立点
				选取最小权值的边， 将连接的节点看作整体
				再选取连接这个整体最小的边， 直到选取所有的顶点
			时间复杂度：：O(|E| + |V|log|V|)
		Kruskal算法：：
			思想::贪心
			算法：：
				将图看成n个孤立点
				每次选取最小的边， 但保证， 边的两个节点不能都在已经已经选取的节点中
				直到选取所有的顶点
			时间复杂度：：ElogE
	连通图：：	
		割点：：
			也称关节点(Articulation Point)， 在无向连通图中，删除一个顶点v及其相连的边后，原图从一个连通分量变成了两个或多个连通分量，则称顶点v为割点
		双连通图：：	
			如果删除一个无向图的任一顶点后，剩下的图仍然连通，那么这样的无向连通图就称为是双连通的（biconnected）
			也可理解为：：一个没有关节点的连通图称为重连通图(biconnected graph)
		连通度：：
			若在连通图上至少删去k个顶点才能破坏图的连通性，则称此图的连通度为k
		求割点：：
			本质就是求：：在图中寻找强连通分量
			两类节点是割点：：
				1， 对根节点u，若其有两棵或两棵以上的子树，则该根结点u为割点
				2， 对非叶子节点u（非根节点），若其子树的节点均没有指向u的祖先节点的回边（回到祖先），说明删除u之后，根结点与u的子树的节点不再连通；则节点u为割点
			Tarjan算法：：
				算法：：DFS + 栈次序号（dfn[u]）的最小值（low[u]）
				时间复杂度：：O(V+E)
	无向图：：
		如果图不是连通的，那么处理所有的结点（以及边）自然需要多次反复调用dfs，每次都生成一棵树，整个集合就是深度优先生成森林（depth-first spanning forest）
	AOE：：
		定义：：
			Activity on Edge, 在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间
		本质：：
			节点多了时间属性， 和关键路径联系在一起
	AOV::
		定义：：
			Activity on Vertices
		本质：：
			节点没有时间， 通常只是拓扑排序， 节点加上时间， 就可转为AOE网， AOV网不能有有向环

	关键路径：：
		每个节点包括（<最早开始，最早结束>duration<最晚开始， 最晚结束>）的AOE网
		算法：：
			1， 拓扑排序，并求得所有节点的<最早开始，最早结束>
				如果得到的拓扑有序序列中顶点个数小于网中顶点数n，则说明网中存在环，不能求关键路径
			2， 拓扑逆序，并求得所有节点的<最晚开始， 最晚结束>
			3， 若节点<最早开始，最早结束> == <最晚开始， 最晚结束>则为关键活动， 组成的路径就是关键路径

	网路流：：
		通俗理解：：自来水厂 + 家
		三个性质：：
			1， 容量限制：：容量 >= 流量
			2， 流量守恒：：流入量 === 流出的量
			3， 斜对称性：：x到y是正流量， 则y到x是负流量
		网络：：就是有源、汇的有向图
		容量网络：：就是关于容量的网络， 基本是不改变的
		流量网络：：就是关于流量的网络， 在求解问题的过程中， 通常在不断的改变， 但是总是满足上述三个性质
			   调整到最后就是最大流网络 同时也可以得到最大流值
		残留网络：：概括了容量网络和流量网络， 最为常用
			   残留网络=容量网络-流量网络
			   当流量值为负时， 残留值甚至会大于容量值
		网络最大流::
			以送货为例， 在可行的情况下，从一个节点到另一个节点所能送达的最大货量即为最大流
			Edmonds-Karp算法::
				别称：：最短路径增广算法 简称EK算法
				基于增广路算法
				思路：：不断的找最短路， 找的方法就是每次找一条边数最少的增广， 也就是最短路径增广
				复杂度：：
					最多O(VE)次增广 可以达到最大流广
		最小割：：
			假设切割水管付出的代价和水管容量成正比	
		增广路算法：：
			增广路定义：：
				从s到t的路径， 路径上每条边残留容量都为正
			基础：：
				增广路定理：：
					Augmenting Path Theorem， 网络达到最大流当且仅当残留网络中没有增广路
			Ford-Fulkerson算法：：
				简称FF方法， 很多网络流算法的基础， 一般都在残留网络中实现
				思路：：每次找出一条从源到汇的能够增加流的路径 调整流值和残留网络 不断调整直到没有增广路为止
		割（边）：：
			通俗理解：：完全割成两部分， 不藕断丝连
			无向图的割集::(Cut Set), C[A,B]是将图G分为A和B两个点集, A和B之间的边的全集
			网络的割集::C[S,T]是将网络G分为s和t两部分点集 S属于s（源）且T属于t（汇）， 从S到T的边的全集
			带权图的割::(Cut)就是割集中边或者有向边的权和
		最大流最小割定理：： 
			核心：：网络的最大流等于最小割
			应用：：
				1， 对于多源多汇问题，只需要添加一个超源点和一个超汇点，将其转化为单源单汇问题
				2， 对于在顶点处有流量限制的问题， 新的图的顶点数是源图的两倍








Sort：：
	排序算法是否稳定，即值相同的元素的排序结果是否和出现的顺序一致
	堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法
	冒泡：：
		数字往后冒， n~1, n方
	插入：：
		新建array， 无序数插有序数， 1~n, n方
		稳定排序
	选择：：
		每次选最大/小, 不用堆， n~1, n方
	希尔：：
		分组插入排序：：子序列分别进行直接插入排序，子序列增量缩减，直到1， 
		O(n^3/2)， 好于直接插入排序的O(n^2)
		不创建新数组， 直接通过Gap后的每个元素， 做直接插入排序
	归并：：
		从两个元素的小组， 不断merge， 快排思维， 和希尔的逆思想类似， 但每次排序都是merge， 不是直接插入
		每次分两部分， 两个操作， sort（）， merge（）
		时间最好， 最坏都是O(nlogn)， 空间O(n)
	堆排序：：
		不断取堆顶
		O(nlgn)， 最坏：O(nlgn)， 空间复杂度：O(1)
	快排：：
		二分思想， 每次随意选最分隔元素， 递归调用
		O（n*lgn）， 最坏：O（n^2）， 空间复杂度：最好，O（logn）， 最坏O（n）
		不稳定排序
	计数：：
		Counting sort， 稳定的排序算法
		适用于正整数， 基本思想是：：数组元素值对应数组索引
		使用一个额外的数组C， 找出最大、最小值， 长度 = Max - Min
		对于数据范围很大的数组，需要大量时间和内存
	桶排序：：
		Bucket sort， 稳定排序， 比快排快， 非常耗空间
		元素属于固定(有限的)的区间, 数据的分布必须均匀
		选出最大，最小值， 划分区间， 桶内排序可用插入排序等
		每个桶就是一个ArrayList， 桶为1时， 和计数排序类似， 区别在于存储元素实际值， 不是存个数
		最差，O(n2)； 最好O(n+k), 空间O(n+k)auxiliary 
	基数排序：：
		Radix sort， 按位从低到高排序， 原因是从影响较小的开始更好
		正、负整数、浮点数都适用
		每次调用桶排序； 如果只是十进制正整数， 则用余数； 其他如浮点数， 则用位运算， 取特定位， 用移位和&得到
		对于负数， 注意最后一步， 整数部分要和负数部分调换
		n个d位数， O(dn+kd)
查找：：
	总体方法：：
		二分， 树， 索引， Hash
	二分：：
		二分查找：：low + 1/2(high - low)
		插值查找：：
			mid根据key离low的距离来定， 不一定是二分，目的是让mid值的变化更靠近关键字key
			mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); 
			如果关键字分布比较均匀， 平均性能比折半查找要好的多
		斐波那契查找::
			利用斐波那契数列的性质，黄金分割的原理来确定mid的位置
			数列越往后, 相邻的两个数的比值越趋向于黄金比例值（0.618）
			n=F(k)-1，n是要排序数组的长度； mid=low+F(k-1)-1， mid左边元素比右边多
			每次判断后， 注意k的变化； 找到相等的值时， 要判断是否为扩展值
			O(logn)，平均性能， 优于折半查找； 最坏情况比折半差
		小结：：
			折半进行加法与除法运算（mid=(low＋high)/2）
			插值查找进行复杂的四则运算（mid=low＋(high-low)*(key-a[low])/(a[high]-a[low])）
			斐波那契查找只是最简单加减法运算（mid=low＋F[k-1]-1）， 在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率
	索引：：
		本质：：两部分， 关键字：记录
		线性索引：：
			稠密索引：：
				按照关键字有序的排列， 每个记录对应一个索引项， 索引项与数据集的记录个数相同
				可以用到折半、插值、斐波那契等查找
			倒排索引：：
				Inverted index， 常用于"查询那些文件包含了某单词"
				本质：：file：content中， 把content里的关键字作为key， 把file作为value
				缺点：：记录号不定长，维护比较困难，插入和删除操作都需要作相应的处理
			分块索引：：
				两条件：：
					块内无序
					块间有序
					例如：：要求第二块所有记录的关键字均要大于第一块中所有记录的关键字
				三内容：：
					每一块中的最大关键字
					块中的记录个数
					指向块首数据元素的指针
				两步：：
					找块：：二分等查找
					找元素：：顺序查找
				最佳情况：：
						分的块数m与块中的记录数t相同
						查找的平均长度=1/2·(n/t+t)+1=t+1=sqrt(n)+1
	二分树和多路树：：	
		多路查找树（muitl-way search tree）：：
			本质也是索引
			2-3树：：
				就是Max degree为3的B树（阶为3）， 也就是节点中元素个数最多为2， 儿子对多为3
				时间复杂度O(logn)
			2-3-4树：：
				就是Max degree为4的B树（阶为4）， 也就是节点中元素个数最多为3， 儿子对多为4
				时间复杂度O(logn)
			B树：：
				设定每个节点最大元素个数 + 1 = 每个节点最多能有的孩子数（degree）
				用于硬盘数据量很大时， 将节点度数调大， 然后可以只读入根节点， 快速查找元素所在块
				搜索， 插入， 删除O(logn)； 空间O(n)
			B+树：：
				所有节点放在叶子节点上，比B树多了非叶子节点的复制，和叶子节点之间的指针
				遍历更方便
				所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字
				删除时，记得删节点对应的索引
			B*树：：
				是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针
		树状数组：：
			Binary Indexed Tree：：
				定义：：
					1， 建立树关系：：
						整体：：儿子推出父亲
						Ci表示indexed的第i项和
						Ai表示原数组第i项的值， i从1开始
						Sum（i）， 表示Ai的前i项和
				理解Ci：：
					找父亲， 就是儿子下标， 从右往左第一个"1"的位置， 加上1 == 父亲下标
					找最左儿子， 就是父亲下标， 从右往左第一个"1"的位置， 减去1， 再在结果值加上1
					Ci就是， 父亲下标开始， 往前数２^k项的和， 包括父下标的值
					公式：：Ci  =  sum{ A[j] |  i – 2^k+ 1 <= j <= i }
						Ci = sum {A[i-lowbit(i)+1]  ~ A[i]}
				理解Sum（i）：：
					A[i]的前i项和
					sum(i) = sum( i – lowbit(i) ) + C[i]
					递归：：
						int sum(int x){
						     return x ? C[x]+ sum( x - lowbit(x)):0;
						}
					非递归：：
						int sum(int x){
					        int s =0;
					        for(int i = x; i ; i -= lowbit(i)){
					            s += c[i];
					        }
					        return s;    
					    }
				理解add(i, v)：：
					在A[i]， 加上v， 只影响自己和祖先结点
					v可以是负数
					如果需要求[x, y]的和，只需要求两次sum函数，然后相减得到，即sum(y) – sum(x-1)
					递归：：
						void add(int x,int v){
						     if(x <= n){
						         C[x]+= v, add( x + lowbit(i), v );
						     }
						}
					非递归：：
						void add(int x,int v){
						    for(int i = x; i <= n; i += lowbit(i)){
						        C[i] += v;
						    }
						}
				理解lowbit（i）：：
					2^i末尾零的数量
					用补码， 与运算， O（1）实现：：
						int lowbit(int x) {
						     return x & -x;
						}
				用途：：点更新，段求和； 段更新，点求值； 逆序模型， 将元素本身作为树状数组的下标
				记忆：：
					lowbit(i)用来找父亲或儿子
					Ci， Sum(i)找儿子， add(i, v)找父亲
					时间复杂度为O(log(n))，空间复杂度为O(n)

		二叉搜索树：：
			左孩子比父节点小，右孩子比父节点大
			中序遍历，可以让结点有序
		平衡二叉树：：
			AVL， 也叫Self-Balancing Binary SearchTree或Height-Balanced Binary Search Tree
			旋转看作拉动齿轮：：
				基础：：它首先是一个二叉排序树
				本质：：二叉排序树， 左小右大
				四种情况：：
					旋转都是三个步骤：：长边做根， 切断长边，原根做另一边 
					最后更新高度：：
						node.height = Math.Max(Height(node.left), Height(node.right)) + 1;
	             		top.height = Math.Max(Height(top.left), Height(top.right)) + 1;
					左左：：
						var top = node.left;
						node.left = top.right;
						top.right = node;
					右右：：
						var top = node.right;
						node.right = top.left;
						top.left = node;
					左右：：
						两次旋转：：
							失衡点的左节点执行右右
							失衡点执行左左
							node.left = RotateRR(node.left);
							return RotateLL(node);
					右左：：
						两次旋转：：
							失衡点的右节点执行左左
							失衡点执行右右
							node.right = RotateLL(node.right);
							return RotateRR(node);
				插入：：
					Height(tree.right) - Height(tree.left) == 2时旋转
					出现了哪一种情况调用哪一种方法
					重复元素加到根节点的set里
				删除：：
					删除中间节点：：
						先删除， 然后用左右高度判断， 使用哪种旋转
					删除根：：
						有两个孩子的情况：：
							找到”右子树“的最小节点：：
								tree.key = FindMin(tree.right).key;
							删除右子树的指定元素：：
								tree.right = Remove(tree.key, value, tree.right);
						只有一边有：：
							tree = tree.left == null ? tree.right : tree.left;
						叶子节点：：
							if (tree == null) {return null};
		Treap：：就是二叉排序树 + 优先级的堆， 一个节点含有value和优先级

	哈希表查找：：
		哈希（Hash）函数 +　记录存储在一块连续的存储空间
		解决冲突：：
			两种方法：：
				跳空格
				重复元素存链表























